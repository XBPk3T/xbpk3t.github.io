---
title: 设计模式
date:  2024-09-14
---

## Design Pattern


:::tip
基本认知

- 设计模式不是硬知识，是经验。需要慢慢品，无法一蹴而就。
- 通过最佳使用场景 (例子) 来学习设计模式是最快的
- 想想不用设计模式怎么实现？该场景下使用各种设计模式实现，分别有什么优劣？对比一下 哪种更好？ (如果不能合理设计，或者用错设计模式，会导致维护更困难，这就是所谓的“反设计/过度设计”)

:::


---


- 创建型模式：在创建对象的同时，隐藏创建逻辑的方式，而不是用 new 直接实例化对象
- 结构型模式：组合类和对象
- 行为型模式：关注对象间的通信


```yaml

- type: Design-Pattern
  repo:
    - url: https://github.com/aierui/design-pattern-in-go
      qs:
        - q: "**What's Design Pattern? What are some common DP?**"

```



### 创建型模式


```yaml
- name: 工厂模式
  code: |
    1. 把某个对象的不同种类定义成 struct
    2. 把该对象的不同属性定义成 interface
    3. 把 struct 整合到NewInterface()



- name: builder 模式
  scenario: 将多个简单对象组装成复杂对象
  examples: |
    1. 基本物料不变，但是其组合方式经常变化，比如装修
    2. 建造者模式所创建的产品，一般具有较多的共同点，其组成部分相似，*如果产品之间的差异性很大，则不适合使用建造者模式*，因此其使用场景有一定的局限性

- name: 原型模式 prototype
  scenario: 其实就是DI依赖注入，在interface里加一个Clone()，这样就可以

```




### 结构型模式



```yaml

- name: 适配器模式 adapter
  scenario: 把原本不兼容的接口，通过适配器进行统一
  examples: 转换器
  usage: ''


- name: 装饰器模式 decorator
  scenario: 不能或者不想通过继承类的方式拓展功能；在不修改原对象的情况下增加新功能 (避免直接继承导致子类膨胀问题)
  examples: 俄罗斯套娃/大众汽车/nokia 手机 科技以换壳为本嘛
  usage: ''


- name: 外观模式 facade
  scenario: 屏蔽内部复杂度，提供一个简单接口，隐蔽内部的复杂子系统
  examples: 用户注册只需要手机号，服务端会从各种渠道获取其他数据
  usage: ''


- name: 代理模式 proxy
  scenario: 给某个对象提供一个代理，并由代理对象控制原对象的引用，为某些资源的访问，对象的类的易用操作上提供方便使用的代理服务；
  examples: 分销商/老大和小弟
  usage: |
    - 和adapter的区别：适配器是连接了两个接口
    - 和decorator的区别：装饰器是对现有的对象进行包装



- name: 组合模式 composite
  scenario: 让我们的服务节点进行自由组合，对外提供服务，如果我们需要对 ABC 三个服务随意进行组合，
  examples: 营销规则决策树，根据不同的性别/年龄发放不同的优惠券
  usage: ''


- name: 桥接模式 bridge
  scenario: 把抽象部分和实现部分分离，不希望使用继承或者因为多层次继承导致系统类的个数急剧增加的系统
  examples: 聚合支付，聚合了支付渠道 (微信/支付宝) 和支付方式 (指纹/人脸)
  usage: ''


- name: 享元模式 flyweight
  scenario: 通过共享通用对象，减少内存使用 || 享元工厂把变化的对象和不变对象组装
  examples: 秒杀场景的商品库存和详情
  usage: ''

```


### 行为型模式

```yaml

- name: 责任链模式 cor
  scenario: 解决一组服务中的先后关系
  examples: 击鼓传花/离职时需要各层领导签字/平时

- name: 命令模式 command
  scenario: 把类似场景拆分成三个部分：命令/命令实现者/命令调用者，有新菜品时可以直接新增，很容易拓展外部调用
  examples: 销售不需要关心生产车间里的具体流程/餐厅服务员不需要关心厨师怎么做菜
  usage: 怎么组合使用命令模式和组合模式？

- name: 中介者模式 mediator
  scenario: >-
    系统中的对象之间存在复杂的引用关系，导致难以复用，通过引入中介者类，封装这些对象之间的引用关系，如果需要改变行为，则引入新的中介者类即可，不需要删除原中介者，
  examples: 交警维持交通秩序

- name: 备忘录模式 memento
  scenario: 属于附加功能，通过记录原对象的行为从而实现备忘录模式，
  examples: 回滚系统

- name: 观察者模式
  scenario: 对象的一种一对多的关系，当依赖的对象的状态发生改变时，所有依赖它的对象都得到通知并被自动更新，可以用观察者模式构建链式触发机制
  examples: MQ 服务的通知中心

- name: 状态模式
  scenario: >-
    对象的行为依赖于他的状态 (属性)，并且可以根据其状态改变而改变相关行为 || 状态模式的核心在于环境类，环境类可以根据不同场景调用不同实现类 ||
    这样的话，客户端不需要像策略模式一样，知道所有实现类的类名，只需要实例化环境类，就可以实现需要的功能
  examples: >-
    代码中包含大量与对象状态有关的条件语句，会导致代码的可维护性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强，在这些条件语句中包含了对象的行为，而且这些条件对应对象的各种状态


- name: 策略模式 strategy
  scenario: 将不同的处理过程进行独立封装，通过接口暴露出去，调用者根据不同场景和条件，使用不同策略不需要了解其中细节

- name: 模版模式 template

- name: 访问者模式 visitor


- name: 解释器模式

- name: 空对象模式

- name: 迭代器模式 iterator
  scenario: 实现 Iterator 接口，通过 next 的方式获取集合元素
  examples: 公司组织架构

```






## [2024/9/1] 《大话设计模式》读书笔记

```markdown
本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GoF总结的23个设计模式。本书共分为29章。其中，第1、3、4、5章着重讲解了面向对象的意义、好处以及几个重要的设计原则；第2章，以及第6到第28章详细讲解了23个设计模式；第29章是对设计模式的全面总结。附录部分是通过一个例子的演变为初学者介绍了面向对象的基本概念。
```


```markdown
设计模式是否有必要全部学一遍？

答案是，Yes！别被那些说什么设计模式大多用不上，根本不用全学的舆论所左右。尽管现在设计模式远远不止23种，对所有都有研究是不太容易的，但就像作者本人一样，在学习GoF总结的23个设计模式过程中，你会被那些编程大师们进行伟大的技术思想洗礼，不断增加自己对面向对象的深入理解，从而更好的把这种思想发扬光大。这就如同高中时学立体几何感觉没用，但当你装修好房子购买家俱时才知道，有空间感，懂得空间计算是如何的重要，你完全可能遇到买了一个大号的冰箱却放不进厨房，或买了开关门的衣橱（移门不占空间）却因床在旁边堵住了门而打不开的尴尬。

重要的不是你将来会不会用到这些模式，而是通过这些模式让你找到“封装变化”​、​“对象间松散耦合”​、​“针对接口编程”的感觉，从而设计出易维护、易扩展、易复用、灵活性好的程序。成为诗人后可能不需要刻意地按照某种模式去创作，但成为诗人前他们一定是认真地研究过成百上千的唐诗宋词、古今名句。如果说，数学是思维的体操，那设计模式，就是面向对象编程思维的体操。
```

按照书中所说，我应该是长期处于第三个阶段了，每种DP都自己实现过不止一次了，但是还是迷糊，除了几种常用的，分不清各自的具体使用场景。






```markdown
简单工厂模式虽然也能解决这个问题，但这个模式只是解决对象的创建问题，而且由于工厂本身包括了所有的收费方式，商场是可能经常性地更改打折额度和返利额度，每次维护或扩展收费方式都要改动这个工厂，以致代码需重新编译部署，这真的是很糟糕的处理方式，所以用它不是最好的办法。面对算法的时常变动，应该有更好的办法。好好去研究一下其他的设计模式，你会找到答案的
```

factory和builder都是通过简单对象搭建复杂对象，但是如果需要经常更改策略内容，比如打折额度和返现额度，需要经常修改factory模式的代码，就应该改成builder模式

```markdown
策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。看来商场收银系统应该考虑用策略模式？

”策略模式（Strategy）​：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。​[DP]

“你问我？你说呢？​”大鸟笑道，​“商场收银时如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种很重要的思维方式。我们来看看策略模式的结构图和基本代码。​”
```


```markdown
“你的意思是，应该在内部组装完毕，然后再显示出来？这好像是建造者模式呀。”

“不是的，建造者模式要求建造的过程必须是稳定的，而现在我们这个例子，建造过程是不稳定的，比如完全可以内穿西装，外套T恤，再加披风，打上领带，皮鞋外再穿上破球鞋；当然也完全可以只穿条裤衩就算完成。换句话就是说，通过服饰组合出一个有个性的人完全可以有无数种方案，并非是固定的。​”

“啊，你说得对，其实先后顺序也是有讲究的，如你所说，先穿内裤后穿外裤，这叫凡人，内裤穿到外裤外面，那就是超人了。​”

“哈，很会举一反三嘛，那你说该如何办呢？​”

“我们需要把所需的功能按正确的顺序串联起来进行控制，这好像很难办哦。​”
```

这里就引出了builder和decorator的区别

***builder是按照固定顺序执行的，但是decorator则不需要***


### 总评

扫了一下，这本书对我来说没啥用。***并且用来举例的小故事其实有点尬，并且不像《趣谈 Linux 操作系统》一样，能用一个故事串起来。***

之后我会自己写一个类似的东西，用一个故事来说明所有的DP



