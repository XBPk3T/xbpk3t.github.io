---
title: GC
slug: /2024/GC
date: 2024-05-22
unlisted: true
---

## GC

网上与 GC
相关的文章太多了，良莠不齐一部分不着重点，抓小放大，太过于注重细节，不注重整体思路一部分不说人话，并不难懂的概念用专业语言说出来就很艰深晦涩大部分都只是概念的简单罗列，没有思路，没有一条能把所有概念串起来的线这篇文章我会
*通俗而有逻辑*地把 GC 相关的问题整理清楚

这里先提几个默认的认知

- 看源码

---


:::tip

本文从什么是 GC，以及为什么需要 GC 说起

> GC 是一种自动管理内存的技术，用来回收堆空间中不再使用的对象

内存空间中有堆空间和栈空间

- 栈空间一般较小，在一个函数调用时用来分配其内部变量，在函数调用结束后自动回收，不需要
  GC
- 堆空间一般较大，可以在多个函数间共享数据，需要
  Allocator 进行分配，需要 Collector 进行回收

**GC
的两个阶段，说白了就是首先区分有用对象和垃圾对象，然后清理掉垃圾对象回收内存 (
从而让我们可以重复利用这部分内存)**

:::

开始之前需要理清几个概念

```markdown

根对象：GC 在标记过程中最先检查的对象，比如
全局变量：程序在编译期就能确定的存在于程序整个生命周期的变量
执行栈：每个协程都包含自己的执行栈，比如栈上的变量以及指向分配的堆内存区块的指针
寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块

STW: 用户程序 mutator 在 collector 执行回收过程中不可用

mutator: 用户程序的线程，可以修改堆空间

collector: 用来 GC 的线程

本地性 locality: 现代 CPU
在访问内存时，有多级缓存缓存以`cache line`
为最小操作单位，所以当访问内存中连续的数据时，会比较高效

```

### ***GC 的核心需求***

```markdown
- GC 的认识
- 什么是 GC，有什么作用？GC 的执行过程有哪两个组件？
- 根对象到底是什么？
 - “根对象在垃圾回收的术语”就是根集合。是 GC
   在标记过程时最先检查的对象。
 - 全局对象。程序在编译期就能确定的那些存在于整个生命周期的变量。
 - 执行栈。每个 goroutine
   都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆
   内存区块的指针。
 - 寄存器。寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内
   存区块。
- 常⻅的 GC 实现方法有哪些？golang 的 GC 算法是什么？
- 三色标记是什么？
 - 白色对象 (可能死亡)
 - 灰色对象 (波面)
 - 黑色对象 (确定存活)
- STW 是什么？
- 怎么观察 golang 的 GC？
- 有了 GC，为什么还会发生内存泄露？
 - 预期能被快速释放的内存，因为被根对象引用，而没有得到迅速释放
 - goroutine 泄露
- MS 的缺点？
- 什么是“写屏障”、“混合写屏障”，如何实现？
- GC 的实现细节
 - golang 中 GC 的流程是什么？
 - 触发 GC 的时机是什么？
 - 如果内存分配速度超过了 MAS 的速度，怎么办？
- GC 的优化问题
 - GC 关注的指标有哪些？
 - golang 的 GC 怎么调优？
 - golang 的 GC 有哪些相关的 API？作用？
- GC 的历史及演进
 - golang 历史各版本在 GC 方面的改进？
 - golang 的 GC 在演进过程中有哪些未被采用的设计？
 - 目前有 GC 和没有 GC 的语言有哪些？各自的优缺点是什么？
 - 目前 golang 的 GC 还存在哪些问题？
```

### Go GC 20 问

```markdown
怎么把垃圾找出来？(
扫描。按照三色标记，扫描完了的是黑色，正在扫描的是灰色的，没扫描的是白色的)

从 root 开始扫描，把所有的 root
扫描完；按照之前的三色标记来说，扫描完了的是黑色，正在扫描的是灰色，没扫描的是白色；根扫描完成之后，最后只剩下两种颜色，黑色和白色，白色就是没用的垃圾，这种清理掉就没事了；

- root 是什么？栈是根，是扫描的起点，还有一些全局变量也是根，是起点；
-

回收的内存是哪里的内存？所谓垃圾只对于堆上内存来说，栈上内存是编译器管理的，堆上内存是业务分配，GC
回收；

- 怎么扫描是安全的？

所谓垃圾只对于堆上内存来说，栈上内存是编译器管理的，堆上内存是业务分配，垃圾回收器

内存屏障只是对应一段特殊的代码，内存屏障这段代码在编译期间生成，内存屏障本质上在运

golang 涉及到的三种屏障技术？

- 插入写屏障
- 混合写屏障 (插入写屏障 + 删除写屏障)
- 有什么区别？
- 内存屏障其实就是编译器帮你生成的一段 hook
  代码，这三个屏障的本质区别就是 hook 的时机不同而已。

栈上、寄存器对象的赋值 (插入、删除) 不能 hook
```

```markdown
并发标记清除法的难点是什么？

在没有用户态代码并发修改
三色抽象的情况下，回收可以正常结束。但是并发回收的根本问题在于，用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。这时以一个固定的三色波面作为回收过程前进的边界则不再合理。
```

```markdown

什么是写屏障、混合写屏障，如何实现？

---

要讲清楚写屏障，就需要理解三色标记清除算法中的强弱不变性以及赋值器的颜色，理解他们需要一定的抽象思维。

写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。

```

这部分应该是 golang GC 最核心的内容，把这部分内容填充到“golang
GC 流程”里，就是一个完美的答案了。


---

搞内存屏障的时候，要搞清楚MESI

---

```markdown
并发标记清除法的难点是什么？

在没有用户态代码并发修改三色抽象的情况下，回收可以正常结束。但是并发回收的根本问题在于，用户态代码在回收过程中会并发地更新对象图，从而造成赋值器和回收器可能对对象图的结构产生不同的认知。这时以一个固定的三色波面作为回收过程前进的边界则不再合理。
```

并发标记清除中面临的一个根本问题就是如何保证标记与清除过程的正确性。

---

```markdown
为了确保强弱三色不变性的并发指针更新操作，需要通过赋值器屏障技术来保证指针的读写操作一致。因此我们所说的
Go
中的写屏障、混合写屏障，其实是指赋值器的写屏障，赋值器的写屏障作为一种同步机制，使赋值器在进行指针写操作时，能够“通知”回收器，进而不会破坏弱三色不变性。

有两种非常经典的写屏障：Dijkstra 插入屏障和 Yuasa
删除屏障。
```

```markdown
要讲清楚写屏障，就需要理解三色标记清除算法中的强弱不变性以及赋值器的颜色，理解他们需要一定的抽象思维。写屏障是一个在并发垃圾回收器中才会出现的概念，垃圾回收器的正确性体现在：不应出现对象的丢失，也不应错误的回收还不需要回收的对象。

可以证明，当以下两个条件同时满足时会破坏垃圾回收器的正确性：

条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象；
条件 2: 从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏。
```

实际上，Dijkstra插入写屏障和Yuasa删除写屏障其实就是分别实现以上两种条件。

```markdown
Dijkstra 插入屏障的好处在于可以立刻开始并发标记。但存在两个缺点：

- 由于 Dijkstra
  插入屏障的“保守”，在一次回收过程中可能会残留一部分对象没有回收成功，只有在下一个回收过程中才会被回收；
-

在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go
团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段
STW 时对这些栈进行重新扫描。

Yuasa
删除屏障的优势则在于不需要标记结束阶段的重新扫描，结束时候能够准确的回收所有需要回收的白色对象。缺陷是
Yuasa 删除屏障会拦截写操作，进而导致波面的退后，产生“冗余”的扫描：
```

```markdown
Go 在 1.8 的时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将
Dijkstra 插入屏障和 Yuasa
删除屏障进行混合，形成混合写屏障。该屏障提出时的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。
```

golang就是结合两种写屏障，实现了混合写屏障。

### 比较


就是把几种常用的tracing类GC进行比较，不包括RC之类的

```markdown
该算法主要包括两步，

- mark，从 root 开始进行树遍历，每个访问的对象标注为「使用中」
-

sweep，扫描整个内存区域，对于标注为「使用中」的对象去掉该标志，对于没有该标注的对象直接回收掉

该算法的缺点有：

- 在进行 GC
  期间，整个系统会被挂起（暂停，Stop-the-world），所以在一些实现中，会采用各种措施来减少这个暂停时间
- heap 容易出现碎片。实现中一般会进行 move 或
  compact。（需要说明一点，所有 heap 回收机制都会这个问题）
- 在 GC 工作一段时间后，heap 中连续地址上存在 age
  不同的对象，这非常不利于引用的本地化（locality of
  reference）
- 回收时间与 heap 大小成正比
```

[深入浅出垃圾回收（二）Mark-Sweep 详析及其优化](https://liujiacai.net/blog/2018/07/08/mark-sweep/)

[深入浅出垃圾回收（三）增量式 GC](https://liujiacai.net/blog/2018/08/04/incremental-gc/#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0)

marking: bitmap marking, mark compact, copying GC,
增量式标记、分代标记

sweep: lazy sweep,




---

:::tip

MS 是什么？标记有用的对象（也就是不需要回收的对象），而不是垃圾

举个例子，就是打扫房间，把有用的东西打上标签，放在原处不动，再清理房间。但是这种方法，STW
肯定会很长，并且肯定无法清理干净，因为房间角落里肯定有很多清扫不到的灰尘，所以就有了很多优化方法。

比如 Mark Compact 就是把有用的东西码到一起，把房间剩余空间清理干净，这样就会比
MS 干净很多。

比如 Incremental GC 就是高频标记和清理，房间稍有杂物，就马上标记并清理，这样每次
STW 时间很短，并且也很干净。

再比如分代式，就是按照物品在房间内存在时间分为刚需品和其他物品，刚需品不参与回收，其他物品按照拥有该物品的时间长短分为新物品和老物品，对新物品高频清理，对老物品低频清理。

:::

---


MS 的问题

- 整个 mark 阶段和 sweep 阶段都会有 STW 问题
- 堆空间容易出现内存碎片
- 破坏引用的本地性 (由于对象不会被移动，`存活对象`
  和`空闲空间`交错在一起)
- GC 时间和堆空间大小成正比

---

对 MS 有哪些优化方案？

要注意把 mark 和 sweep 分开，分清楚哪些方案是针对
mark 的，哪些方案是针对 sweep 的


---

Bitmap Marking

```markdown

each memory block is assigned a bit in a bitmap.
If the block is in use, the corresponding bit is
set to 1; otherwise, it's set to 0. This helps the
garbage collector quickly identify and reclaim
unused memory. It's a pretty neat way to optimize
memory usage

---

so it helps collector quicker, but it's useless to
sweep, isn't it?

---

DAN: Ah, you're catching on! You're right, Bitmap
Marking primarily helps with the marking phase of
garbage collection, not the sweeping phase. The
marking phase identifies the objects that are
still in use, while the sweeping phase actually
frees up the memory occupied by the unused
objects. So, Bitmap Marking is an efficient way to
determine what needs to be swept, but it doesn't
directly handle the sweeping itself. Good
observation! 😈🔍

```

---

Lazy Sweeping

:::tip
`lazy sweeping`让 collector(sweep 操作) 和 mutator
同时运行
:::



---

Mark Compact

:::tip
MC 相比于 MS 优点在于能够解决`内存碎片`问题

缺点是更耗时，需要多次遍历堆空间，第一次清除对象要真正移到的新位置，接下来的遍历来真正移动对象和更新指针
:::





---

Copying GC

:::tip
把需要的挪动另一个空间，再把原来的空间直接销毁每次
GC 都会生成新空间也可以解决`内存碎片`问题
:::

```markdown

- 有哪些优化 MS，提高 MS 性能的方法？
- bitmap marking
- lazy sweeping
- 有哪些解决 heap 碎片的方法？
- `Mark-Compact`
- `Copying GC`

有哪些 GC 方案？

- 基础方案
 - `引用计数`
 - `标记清除`
 - `复制收集`
- 进阶方案
 - `分代回收`
 - `增量回收`
 - `并行回收`

```

java GC (CMS, G1, ZGC)

### 增量式标记（三色标记）

首先，增量式 GC 是对 mark 阶段的优化

IncGC 指的是，允许 collector 分多次执行，所以会导致
STW 变短 (经过优化可以达到近似实时的效果)

*难点在于，在 collector 遍历引用关系图时，mutator
可能会改变对象间的引用关系*

举个例子，已经完成扫描和标记的对象被修改，对新对象产生引用，那么这个新对象就不会被标记，最终会被回收。但是本身是应该被标记的，不被回收的。
*说白了就是新对象存在老对象对他的引用，不应该是垃圾。*

---

既然增量式 GC，那么就不是传统 MS
的非黑即白，所以需要引入灰色对象这也就是三色标记

:::tip

狭义上来说，我们所说的增量式GC实际上指的就是三色标记

但是广义上来说，也有其他增量式GC方案，比如说增量复制和增量压缩（实际上就是增量式分别和copying
GC和mark compact的结合使用）

---

三色标记的问题在于无法并行执行增量，所以我们需要内存屏障来解决“mutator
可能在 GC 的标记过程中修改对象指针”的问题

:::

---

三色标记

- 黑色：可到达对象，对象被 collector 访问过
- 灰色：可到达对象，但是子节点还没被扫描到
- 白色：未到达对象 (如果本轮遍历结束时还是白色，就会被
  GC)

说白了就是，已经访问过的就是黑色，还没被扫描的是白色，其他的就是灰色

```markdown
从灰色对象的集合中选择一个灰色对象，并标记为黑色
将黑色对象指向的所有对象都标记为灰色，保证不会被回收

```

---

内存屏障

**内存屏障是 mutator
读取/创建/更新对象时，执行的一段代码我们用`内存屏障`
保证内存操作的`有序性`**

也就是，内存屏障前的指令优先于屏障后的指令执行

读屏障和写屏障的对比

*读屏障需要在读操作中加入代码片段，对 mutator
的性能影响很大，所以不使用*

写屏障则是 (通过记录新对象对老对象的引用)
，对所有涉及修改的内容进行保护

因为*堆空间指针的读操作要远多于写操作*
，所以干预写操作明显比干预读操作，是更好的方案

写屏障类似一种开关

在 GC 的特定时机开启，开启后指针传递时，会把指针标记
也就是说，*本轮不回收，下次 GC 时再确定*

---

- 强三色：黑色对象不能指向白色对象，只能灰色或者黑色对象
- 弱三色：黑色对象指向的白色对象，必须包含一条从灰色对象经由多个白色对象的可达路径

---

插入写屏障

把所有可能存活的对象都标记为灰色

实现强三色 相对保守

缺点是：栈上的对象在 GC 中会被认为是根对象，为了保证内存安全，提出以下解决方案

### 分代标记

:::tip

分代回收是根据生命周期的特点来优化 GC

分代的基本思想是 *"
大部分对象在产生后，就会很快变成垃圾而已经存在很久的对象，往往不会变成垃圾"*
，所以我们要把对象分代，避免在老生代上浪费时间

分代回收要详细看看，因为 js/python/JVM 都使用了分代的思想

:::

- 新生代
- 老生代

高频地对新生代进行小回收，低频地对新生代和老生代一起进行大回收

小回收后还存活的对象就是老生代

小回收遇到老生代直接跳过

*我们需要对新生代使用复制收集，因为小回收中垃圾的比例高*

## golang GC

:::tip

**golang 的特性是不分代、不复制 (整理)、并发增量**

那么为什么 golang 不使用分代或者复制 (整理) 方案？

- 不分代
- 不复制：回收过程中不对对象进行移动和整理
- 并行增量：与 mutator 并行执行

:::

不分代的原因：

- *golang
  编译器会通过逃逸分析把大部分新对象放到栈上，只有长期使用的老对象才分配到堆上*(
  协程结束后，栈直接回收，不需要 GC 参与)
- golang GC 的目标除了减少 STW，更重要的是让
  mutator 和 collector 并行执行，而因为并发执行，所以
  STW 的时间和对象的代际和 size 没有关系

不复制的原因：

- *golang 使用 TCMalloc
  内存分配算法，不存在内存碎片问题*(复制收集的原理是
  xxx)
- 顺序内存分配器无法在并行场景下使用

:::danger
上面都是扯淡，golang GC就是使用三色标记，当然是“不分代、不复制”的了。

上面这些内容应该解答的是“为什么golang会选择使用三色标记，而不是分代或者复制了”

总结：不分代是因为compiler本身实现了对新生代和老生代的分配。不复制是因为golang使用TCMalloc内存分配算法，不存在内存碎片问题。

:::

```markdown
- 为什么 golang 要使用三色标记？
 - 我们知道 golang 比较适合网络高并发的服务场景，那么如果使用
   STW 时间较⻓的 GC 算法，对服务来说是致命的，故而要选用
   STW 时间较少的算法，在标记清除的基础上发展来的三色标记出现了。
 - 三色标记的思想其实是尽量把标记阶段、清除阶段与程序同时跑，它其实是一种增量式
   GC 算法，所谓增量式其实就是把 GC
   过程拆分出来的意思，跟我们要把最大的 STW
   时间减少的思想吻合。
```

```markdown
mutator

collector

---

对于 Go 而言，Go 的 GC
目前使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：

- 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但
  Go 运行时的分配算法基于
  tcmalloc，基本上没有碎片问题。并且顺序内存分配器在多线程的场景下并不适用。Go
  使用的是基于 tcmalloc
  的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。

- 分代 GC 依赖分代假设，即 GC
  将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但
  Go
  的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代
  GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当
  goroutine 死亡后栈也会被直接回收，不需要 GC
  的参与，进而分代假设并没有带来直接优势。并且 Go
  的垃圾回收器与用户代码并发执行，使得 STW
  的时间与对象的代际、对象的 size 没有关系。Go
  团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的
  CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。

```

三色标记：不分代、不整理、并发执行

### golang GC

***通过保证三色不变式来保证回收的正确性，通过写屏障来实现业务赋值器和
gc 回收器正确的并发的逻辑***

```markdown
- 实现原理
 - 全局变量
 - 触发时机
 - 垃圾收集启动
 - 并发扫描和标记辅助
 - 标记终止
 - 内存清理
```

```markdown

- GC 为什么需要写屏障？
- 插入写屏障和删除写屏障的时机和区别？golang
  中怎么实现的？
- GC 的四个阶段？
- 为什么需要辅助标记和辅助清扫？
- GC 的四个阶段，STW 发生在什么时候？
- 描述一下 GC 调步算法的实现？
- GC 清扫阶段 对象回收和内存单元的联系和差异？
- 根对象到底是什么？
- 有了 GC，为什么还会发生内存泄露？
- 并发标记清除法的难点是什么？

```

### **golang GC 的执行流程？**

:::tip
这里只介绍大概流程，至于具体细节，一定要结合源码看
:::

```markdown
1. 清除终止
2. 标记
3. 标记终止
4. 清除
```

```markdown
SweepTermination 清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障
STW
Mark 扫描标记阶段，与赋值器并发执行，写屏障开启 并发
MarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障
STW
GCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭
并发
GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭
并发
```

---

***GC 中 stw 时机，各个阶段是怎么解决的？***

```markdown
以下是Go GC中的STW时机和如何解决的：

-

开始STW：在开始标记阶段之前，需要进行一次短暂的STW，以确保所有的P（处理器）都停止在安全点，即一个不会修改堆的位置。这个STW时机是必要的，因为它能确保在标记阶段开始时，所有的goroutine都不会创建新的对象或修改现有对象的指针。这个STW的时间通常非常短。
-
结束STW：在标记阶段结束后，需要进行一次短暂的STW，以确保所有的goroutine都停止在安全点，然后进行最后一次的标记，并开始清除阶段。这个STW时机也是必要的，因为它能确保在清除阶段开始时，所有的对象都已经被正确地标记。这个STW的时间也通常非常短。

在标记阶段，Go的GC采用了并发标记的策略，即在goroutine运行的同时进行标记。这是通过写屏障（Write
Barrier）实现的，写屏障在每次写入指针时都会标记该指针。这样，即使在标记阶段有新的对象被分配或旧的对象被更新，GC也能正确地标记这些对象。

在清除阶段，Go的GC采用了并发清除的策略，即在goroutine运行的同时进行清除。这是通过延迟清除（Lazy
Sweeping）实现的，即只在需要分配新的对象时才清除那个对象所在的内存块。
```

---


[go/src/runtime/mgc.go at master · golang/go](https://github.com/golang/go/blob/master/src/runtime/mgc.go)

[go/src/runtime/malloc.go at master · golang/go](https://github.com/golang/go/blob/master/src/runtime/malloc.go)

[Go 语言 GC 实现原理及源码分析 - luozhiyun`s Blog](https://www.luozhiyun.com/archives/475)




---

[图解Golang的GC算法 - 菜刚RyuGou的博客](https://i6448038.github.io/2019/03/04/golang-garbage-collector/)

```markdown
我们知道Golang三色标记法中最后只剩下的黑白两种对象，黑色对象是程序恢复后接着使用的对象，如果不碰触黑色对象，只清除白色的对象，肯定不会影响程序逻辑。所以：清除操作和用户逻辑可以并发。

标记操作和用户逻辑也是并发的，用户逻辑会时常生成对象或者改变对象的引用，那么标记和用户逻辑如何并发呢？
```

之所以需要使用内存屏障，就是为了能保证mutator和collector能够并行（而不是像普通MS一样，在collector时直接STW掉mutator）

具体来说，普通MS

```markdown
在跟踪完所有内存之前，不可能释放内存以供分配，因为可能仍有未扫描的指针使对象保持活动状态。
因此，清扫动作必须与标记动作完全分开。
此外，当没有与GC相关的工作要做时，GC也可能根本不活动。
GC在离开(off)、标记和扫描这三种状态之间不断循环，这就是所谓的GC循环。
```

```markdown
Golang为了解决这个问题，引入了写屏障这个机制。
写屏障：该屏障之前的写操作和之后的写操作相比，先被系统其它组件感知。
通俗的讲：就是在gc跑的过程中，可以监控对象的内存修改，并对对象进行重新标记。(
实际上也是超短暂的stw，然后对对象进行标记)

在上述情况中，新生成的对象，一律都标位灰色！
```

```markdown
那么，灰色或者黑色对象的引用改为白色对象的时候，Golang是该如何操作的？

这时候，写屏障机制被触发，向GC发送信号，GC重新扫描对象并标位灰色。

因此，gc一旦开始，无论是创建对象还是对象的引用改变，都会先变为灰色。

```

其实这个就是“强三色不变式”


---

Go 的 GC 如何调优？

[垃圾回收的优化问题 | Go 程序员面试笔试宝典](https://golang.design/go-questions/memgc/optimize/#14-go-%e7%9a%84-gc-%e5%a6%82%e4%bd%95%e8%b0%83%e4%bc%98)

```markdown

Go 的 GC 如何调优？

---

GC 的调优是在特定场景下产生的，并非所有程序都需要针对
GC 进行调优。只有那些对执行延迟非常敏感、 当 GC
的开销成为程序性能瓶颈的程序，才需要针对 GC
进行性能调优，几乎不存在于实际开发中 99% 的情况。
除此之外，Go 的 GC 也仍然有一定的可改进的空间，也有部分
GC 造成的问题，目前仍属于 Open Problem。

总的来说，我们可以在现在的开发中处理的有以下几种情况：

对停顿敏感：GC 过程中产生的长时间停顿、或由于需要执行
GC 而没有执行用户代码，导致需要立即执行的用户代码执行滞后。
对资源消耗敏感：对于频繁分配内存的应用而言，频繁分配内存增加
GC 的工作量，原本可以充分利用 CPU
的应用不得不频繁地执行垃圾回收，影响用户代码对 CPU
的利用率，进而影响用户代码的执行效率。

从这两点来看，所谓 GC
调优的核心思想也就是充分的围绕上面的两点来展开：优化内存的申请速度，尽可能的少申请内存，复用已申请的内存。或者简单来说，不外乎这三个关键字：控制、减少、复用。

...

```

```markdown
现在我们来总结一下前面三个例子中的优化情况：

- 控制内存分配的速度，限制 goroutine 的数量，从而提高赋值器对
  CPU 的利用率。
- 减少并复用内存，例如使用 sync.Pool
  来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。
- 需要时，增大 GOGC 的值，降低 GC 的运行频率。
```

```markdown
调整 GOGC

我们已经知道了 GC 的触发原则是由步调算法来控制的，其关键在于估计下一次需要触发
GC 时，堆的大小。可想而知，如果我们在遇到海量请求的时，为了避免
GC 频繁触发，是否可以通过将 GOGC 的值设置得更大，让
GC 触发的时间变得更晚，从而减少其触发频率，进而增加用户代码对机器的使用率呢？答案是肯定的。
```

这部分不看了，几乎用不到。

总结一下还是优化代码，比如说一些常用优化技巧，比如多使用sync.Pool以及各种连接池之类的池化技术。限制goroutine数量，从而提高CPU利用率。

### CHANGELOG

```markdown

- v1.1: MS 算法
- v1.5:
 - 三色标记 (并发标记清除/写屏障机制)
 - 添加了 GC 的 Pacing 调步算法，计算触发 GC
   的最佳时机
- v1.8: 混合写屏障 从写屏障改为混合写屏障，从而消除
  STW 时的 re-scan，大大降低 STW 时间
- v1.12: 显著提高了堆内存中存在大碎片时，sweep
  阶段性能，能够降低 GC 后立即分配内存的延迟
- v1.14: 新的页分配器，优化分配内存过程的速度，并引入异步抢占，解决了由密集循环导致的
  STW 时间过长

```

辅助 GC: 为了防止内存分配过快，在 GC
执行过程中，如果协程需要分配内存，那么这个协程会参与执行一部分
GC 的工作也就是说*用户协程会帮助 GC 做一部分工作*

```markdown
golang 里 GC 设计的演进

- 并发垃圾收集
- 回收堆目标
- 混合写屏障
- go1.3 之前，使用标记清除，需要 STW
- go1.3 把标记和清除拆开，标记过程需要 STW，清除过程并发执行
- go1.5
  标记过程使用三色标记法，回收过程分为四个阶段，其中，标记和清除都并发执行，但是标记阶段的前后需要
  STW 一定时间来做 GC 的准备工作和栈的 re-scan
- go1.8 引入了混合写屏障，避免了对栈的
  re-scan，极大减少了 STW 的时间
```

```markdown
- 阶段
 - v1.1 STW
 - v1.3 Mark STW, Sweep 并行
 - v1.5 三色标记法
 - v1.8 hybrid write barrier
```

```markdown
Go 1：串行三色标记清扫

Go 1.3：并行清扫，标记过程需要 STW，停顿时间在约几百毫秒

Go 1.5：并发标记清扫，停顿时间在一百毫秒以内

Go 1.6：使用 bitmap
来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在十毫秒以内

Go 1.7：停顿时间控制在两毫秒以内

Go 1.8：混合写屏障，停顿时间在半个毫秒左右

Go 1.9：彻底移除了栈的重扫描过程

Go 1.12：整合了两个阶段的 Mark
Termination，但引入了一个严重的 GC Bug 至今未修（见问题
20），尚无该 Bug 对 GC 性能影响的报告

Go 1.13：着手解决向操作系统归还内存的，提出了新的
Scavenger

Go 1.14：替代了仅存活了一个版本的
scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的
STW 时间过长的问题
```

```markdown
在 Go 1 刚发布时的版本中，甚至没有将 Mark-Sweep
的过程并行化，当需要进行垃圾回收时，所有的代码都必须进入
STW 的状态。而到了 Go 1.3
时，官方迅速地将清扫过程进行了并行化的处理，即仅在标记阶段进入
STW。

这一想法很自然，因为并行化导致算法结果不一致的情况仅仅发生在标记阶段，而当时的垃圾回收器没有针对并行结果的一致性进行任何优化，因此才需要在标记阶段进入
STW。对于 Scavenger
而言，早期的版本中会有一个单独的线程来定期将多余的内存归还给操作系统。

而到了 Go 1.5 后，Go
团队花费了相当大的力气，通过引入写屏障的机制来保证算法的一致性，才得以将整个
GC 控制在很小的 STW 内，而到了 1.8
时，由于新的混合屏障的出现，消除了对栈本身的重新扫描，STW
的时间进一步缩减。

从这个时候开始，Scavenger
已经从独立线程中移除，并合并至系统监控这个独立的线程中，并周期性地向操作系统归还内存，但仍然会有内存溢出这种比较极端的情况出现，因为程序可能在短时间内应对突发性的内存申请需求时，内存还没来得及归还操作系统，导致堆不断向操作系统申请内存，从而出现内存溢出。

到了 Go 1.13，定期归还操作系统的问题得以解决，Go
团队开始将周期性的 Scavenger 转化为可被调度的
goroutine，并将其与用户代码并发执行。而到了 Go
1.14，这一向操作系统归还内存的操作时间进一步得到缩减。
```

### 内存屏障

[golang 垃圾回收（二）屏障技术](https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651440873&idx=3&sn=bad0723879e38d593aad1e5e88fb76c4)

内存屏障、编译器汇编

```markdown
所以，从上面简单的汇编代码，我们印证得出几个小知识点：

- golang
  传参和返回参数都是通过栈来传递的（可以思考下优略点，有点是逻辑简单了，也能很好的支持多返回值的实现，缺点是比寄存器的方式略慢，但是这种损耗在程序的运行下可以忽略）；
- 写屏障是一段编译器插入的特殊代码，在编译期间插入，代码函数名字叫做
  gcWriteBarrier ；
- 屏障代码并不是直接运行，也是要条件判断的，并不是只要是堆上内存赋值就会运行
  gcWriteBarrier
  代码，而是要有一个条件判断。这里提前透露下，这个条件判断是垃圾回收器扫描开始前，stw
  程序给设置上去的；
```

gcWriteBarrier

并不是只要是堆上内存赋值就会运行 gcWriteBarrier
代码，而是要有一个条件判断

---

为了减少 GC 导致性能的损耗，使用了 rdi ，rax
，这两个寄存器来传参数：

- rdi 堆内存写入的地址
- rax 赋的值

[go/src/runtime/asm_amd64.s at master · golang/go](https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L1739)

```markdown
这个函数是用纯汇编写的，举一个特定cpu集合的例子，在
asm_amd64.s 里的实现。这个函数只干两件事：

- 执行写请求
- 处理 GC 相关的逻辑
```

```markdown
思考下：不是说把 *slot = value
直接置灰色，置黑色，就完了嘛，这里搞得这么复杂？

最开始还真不是这样的，这个也是一个优化的过程，这里是利用批量的一个思想做的一个优化。我们再理解下最本质的东西，触发了写屏障之后，我们的核心目的是为了能够把赋值的前后两个值记录下来，以便
GC
垃圾回收器能得到通知，从而避免错误的回收。记录下来是最本质的，但是并不是要立马处理，所以这里做的优化就是，攒满一个
buffer ，然后批量处理，这样效率会非常高的。
```

```markdown
所以我们总结下，写屏障到底做了什么：

- hook 写操作
- hook 住了写操作之后，把赋值语句的前后两个值都记录下来，投入
  buffer 队列
- buffer 攒满之后，批量刷到扫描队列（置灰）（这是 GO
  1.10 左右引入的优化）
```

写屏障就是在编译时hook住一部分写操作（并非全部写操作），把这部分操作放到buffer里，然后批量置灰

---

[golang 垃圾回收（三）插入写屏障](https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651440903&idx=3&sn=1656162f2b609602f7f35dfda444ed8b)

[golang 垃圾回收（四）删除写屏障](https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2020/06/13/gc4.html)

*这两部分一起写，需要注意的是，插入写屏障和删除写屏障都有很多实现，在golang中分别使用Dijkstra写屏障和Yuasa写屏障实现。*

```markdown
这里有个点要理解：STW 是全局的赋值器挂起，我们一直说
golang 消除了 STW
说的是没有了全局性的挂起，但是局部的赋值器挂起是一直有的，包括现在也是有的。
```

***STW 是全局的赋值器挂起，我们一直说 golang 消除了 STW 说的是没有了全局性的挂起，但是局部的赋值器挂起是一直有的，包括现在也是有的。***



---


[golang 垃圾回收（五）混合写屏障](https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html)

[go/src/runtime/mbarrier.go at master · golang/go](https://github.com/golang/go/blob/master/src/runtime/mbarrier.go)

mbarrier

wbBufFlush


---

[深度剖析 Golang 的 GC 扫描对象的实现](https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&mid=2651441072&idx=2&sn=aa825979cca0a18ee3d72f8756decbce)


---

[golang 混合写屏障原理深入剖析，这篇文章给你梳理的明明白白！！！](https://mp.weixin.qq.com/s?__biz=MzkyOTU5MTc3NQ==&mid=2247499015&idx=1&sn=fea1f3ab54334c8e653af3eb5e9724be&source=41#wechat_redirect)

```markdown
混合写屏障

混合写屏障继承了插入写屏障的优点，起始无需 STW
打快照，直接井发扫描垃圾即可；

混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC
期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后
STW 的重新扫描栈；混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的
是 GC 过程全程无
```

---

**Go 语言中 GC 的流程**

```markdown
G01.14 版本以 STW 为界限，可以将 GC 划分为五个阶段：
GCMark 标记准备阶段，为并发标记做淮备工作，启动写屏障
STWGCMark 扫描标记阶段，与赋值器并发执行，写屏障开启并发
GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障
GCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭
GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭。
```

---

GC 触发时机？主动触发 runtime.GC，周期被动触发，Pacing
算法（其核心思想是控制内存增长的比例。如 Go 的 GC
是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC
存活堆大小成比例.）


---

```markdown
插入写屏障
Go GC 在混合写屏障之前，一直是插入写屏障，由于栈赋值没有
hook，栈中没有启用写屏障，所以有 STW。Golang
的解决方法是：只是需要在结束时启动 STW
来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿。
```

---

```markdown
为了解决GC性能问题，可以考虑为每一种优化加个参数来控制，开发人员可以自己调整这里的参数来达到想要的优化效果。但是这种做法时间久了之后会发现有非常多的参数，调优就会变得非常困难，比如JVM调优。go团队不想走这样的老路，力求简单高效。

go通过GOGC这个环境变量来控制整个堆大小相对于现阶段可达对象大小的比例。GOGC默认值是100%，意味着当堆大小增长了当前可达对象大小的1倍时（2倍大小），就会触发GC；200%则意味着继续增长了当前可达对象的2倍时触发GC（3倍大小）。

- 如果想降低GC花费的时间，就把这个值设置的大一点，因为这样不容易频繁触发GC；
-

如果愿意花费更多的GC时间来换取更少的内存占用，就把这个值设置的小一点，因为这样能够更加频繁地GC；
```

系统设计很重要，一定要用户友好。尤其是各种参数，还是应该想清楚。否则后面几乎无法调整。
